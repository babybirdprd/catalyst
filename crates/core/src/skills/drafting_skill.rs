//! # Drafting Skill
//!
//! Stateless LlmFunction for parallel file drafting in the Speed Demon architecture.
//!
//! ## Key Design Decisions
//!
//! - **Stateless**: No file I/O, no tools - pure LLM call returning source code
//! - **Parallel-safe**: Can run 10-100 instances concurrently
//! - **Single file focus**: Each call generates exactly one file
//!
//! ## Flow
//!
//! ```text
//! Taskmaster → DraftingMission[] → Coordinator spawns N DraftingSkill calls
//!                                           ↓
//!                                   DraftingOutput[] (in-memory)
//!                                           ↓
//!                                   Bulk write to worktree
//!                                           ↓
//!                                   Lead Builder verifies
//! ```

use crate::models::ModelConfig;
use crate::run_llm_function;
use radkit::macros::LLMOutput;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

/// A mission describing a single file to draft
///
/// Generated by Taskmaster as part of the mission plan.
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, LLMOutput)]
pub struct DraftingMission {
    /// Target file path (relative to project root)
    pub file_path: String,
    /// Function/struct signatures this file must implement
    #[serde(default)]
    pub signatures_to_match: Vec<String>,
    /// Natural language summary of what this file should do
    pub logic_summary: String,
    /// Other files this depends on (for import hints)
    #[serde(default)]
    pub dependencies: Vec<String>,
    /// Existing code to preserve or extend (if modifying)
    #[serde(default)]
    pub existing_code: Option<String>,
}

/// Output from drafting a single file
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, LLMOutput)]
pub struct DraftingOutput {
    /// File path (echoed from mission)
    pub file_path: String,
    /// Generated source code (raw string)
    pub source_code: String,
    /// Imports/dependencies used in this file
    #[serde(default)]
    pub imports_used: Vec<String>,
    /// Brief explanation of implementation choices
    #[serde(default)]
    pub notes: Option<String>,
}

/// Stateless drafting skill for parallel file generation
///
/// Unlike other skills, DraftingSkill has no A2A handler - it's called
/// directly by the Coordinator via the static `draft()` method.
pub struct DraftingSkill;

impl DraftingSkill {
    /// Draft a single file based on the mission
    ///
    /// This is the core parallel-safe entry point. It:
    /// 1. Formats the mission into a prompt
    /// 2. Calls the LLM via LlmFunction<DraftingOutput>
    /// 3. Returns the generated code
    ///
    /// No file I/O occurs - the Coordinator handles bulk writes.
    pub async fn draft(
        mission: &DraftingMission,
        config: &ModelConfig,
    ) -> anyhow::Result<DraftingOutput> {
        let prompt = format_drafting_prompt(mission);

        let result = run_llm_function!(config, DraftingOutput, SYSTEM_PROMPT, &prompt)?;

        Ok(result)
    }

    /// Draft multiple files in parallel (convenience wrapper)
    ///
    /// Uses JoinSet for true parallelism. Returns all outputs or first error.
    pub async fn draft_batch(
        missions: Vec<DraftingMission>,
        config: &ModelConfig,
    ) -> anyhow::Result<Vec<DraftingOutput>> {
        use std::sync::Arc;
        use tokio::task::JoinSet;

        let config = Arc::new(config.clone());
        let mut join_set = JoinSet::new();

        for mission in missions {
            let cfg = config.clone();
            join_set.spawn(async move { Self::draft(&mission, &cfg).await });
        }

        let mut outputs = Vec::new();
        while let Some(result) = join_set.join_next().await {
            outputs.push(result??);
        }

        Ok(outputs)
    }
}

/// Format the drafting prompt from a mission
fn format_drafting_prompt(mission: &DraftingMission) -> String {
    let mut prompt = format!(
        "## File to Generate\n\n**Path:** `{}`\n\n**Purpose:** {}\n\n",
        mission.file_path, mission.logic_summary
    );

    if !mission.signatures_to_match.is_empty() {
        prompt.push_str("## Required Signatures\n\n");
        for sig in &mission.signatures_to_match {
            prompt.push_str(&format!("```rust\n{}\n```\n\n", sig));
        }
    }

    if !mission.dependencies.is_empty() {
        prompt.push_str("## Dependencies (for imports)\n\n");
        for dep in &mission.dependencies {
            prompt.push_str(&format!("- `{}`\n", dep));
        }
        prompt.push('\n');
    }

    if let Some(existing) = &mission.existing_code {
        prompt.push_str("## Existing Code to Preserve/Extend\n\n");
        prompt.push_str(&format!("```rust\n{}\n```\n\n", existing));
    }

    prompt
}

const SYSTEM_PROMPT: &str = include_str!("defaults/drafter.md");

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_drafting_mission_serialization() {
        let mission = DraftingMission {
            file_path: "src/lib.rs".to_string(),
            signatures_to_match: vec!["pub fn add(a: i32, b: i32) -> i32".to_string()],
            logic_summary: "Basic addition function".to_string(),
            dependencies: vec!["std".to_string()],
            existing_code: None,
        };

        let json = serde_json::to_string(&mission).unwrap();
        assert!(json.contains("src/lib.rs"));
    }

    #[test]
    fn test_format_drafting_prompt() {
        let mission = DraftingMission {
            file_path: "src/math.rs".to_string(),
            signatures_to_match: vec!["pub fn multiply(a: i32, b: i32) -> i32".to_string()],
            logic_summary: "Multiplication utilities".to_string(),
            dependencies: vec![],
            existing_code: Some("// existing header".to_string()),
        };

        let prompt = format_drafting_prompt(&mission);
        assert!(prompt.contains("src/math.rs"));
        assert!(prompt.contains("multiply"));
        assert!(prompt.contains("existing header"));
    }
}
